import { clsx, type ClassValue } from "clsx";
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";
import { toast } from "sonner";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

/**
 * Formatea un valor numérico como precio en formato MXN,
 * donde los dos últimos dígitos representan centavos.
 *
 * Ejemplos:
 * - 10000 => $100.00
 * - 12345 => $123.45
 * - 50 => $0.50
 *
 * @param amount - Valor numérico donde los dos últimos dígitos son centavos
 * @returns Cadena formateada con el precio
 */
export const formatPrice = (amount: number): string => {
  // Dividir por 100 para convertir los últimos dos dígitos a centavos
  const valueWithDecimals = amount / 100;

  // Usar Intl.NumberFormat para formatear con símbolo de moneda y dos decimales fijos
  return new Intl.NumberFormat("es-MX", {
    style: "currency",
    currency: "MXN",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(valueWithDecimals);
};

// Lista de palabras ofensivas de 4 letras para evitar
const BLACKLIST = [
  "PUTO",
  "PUTA",
  "CULO",
  "CACA",
  "MOCO",
  "CAGA",
  "ANAL",
  "TETA",
  "PEDO",
  "PAJA",
  "CONO",
  "RABO",
  "PITO",
  "MAME",
  "JOTO",
  "COLA",
  "COME",
  "FALO",
  "FETO",
  "GUEY",
  "HUEV",
  "KACA",
  "KAGA",
  "KAKA",
  "KULO",
  "LAME",
  "LOCA",
  "MAMO",
  "MEAR",
  "MEON",
  "MIAR",
  "MION",
  "NACA",
  "NACO",
  "PEDA",
  "PENE",
  "POPO",
  "QULO",
  "RATA",
  "ROBA",
  "SIDA",
  "VACA",
  "VAGA",
  "VAGO",
  "WEBO",
  "WEON",
  "WEVA",
  "WEVO",
  "PAJA",
  "CAGO",
  "COJA",
  "PUTA",
  "PUTO",
  "ZORA",
  "PENE",
  "PITO",
  "PIJA",
  "CACA",
  "CULO",
  "CAGO",
  "CAGA",
  "MOCO",
  "MION",
  "PEDO",
  "ORTO",
  "OJTE",
  "OJTE",
  "PUTA",
  "PUTO",
  "RABO",
  "TETA",
  "VERG",
  "WEBO",
  "WEVA",
];

/**
 * Generate a 4 character reference from a given name.
 * The reference is generated by taking the first letter of each word,
 * and adding more letters from the first word if necessary.
 * If the generated reference is in the blacklist, the last character
 * is replaced with 'X'.
 * @param name The name to generate the reference from
 * @returns A 4 character reference string
 */
export function generateReferenceFromName(name: string): string {
  // Remove special characters and spaces
  const cleanName = name
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "") // Remove accents
    .replace(/[^\w\s]/gi, "") // Remove special characters
    .replace(/\s+/g, " ") // Replace multiple spaces with one
    .trim()
    .toUpperCase();

  // Generate initial reference
  let reference = "";
  const words = cleanName.split(" ");

  if (words.length === 1) {
    // If only one word, take first 4 characters
    reference = words[0].substring(0, 4);
  } else {
    // If multiple words, take first letter of each word
    for (let i = 0; i < Math.min(words.length, 4); i++) {
      if (words[i].length > 0) {
        reference += words[i].charAt(0);
      }
    }

    // If we don't have 4 letters yet, add more from the first word
    if (reference.length < 4 && words[0].length > 1) {
      reference += words[0].substring(1, 5 - reference.length);
    }
  }

  // Ensure reference is exactly 4 characters
  reference = reference.padEnd(4, "X").substring(0, 4);

  // Check if reference is in blacklist
  if (BLACKLIST.includes(reference)) {
    // Replace the last character with 'X'
    reference = reference.substring(0, 3) + "X";
  }

  return reference;
}

/**
 * Maneja la invitación de negocio después de la autenticación
 * @param userId ID del usuario autenticado
 * @param businessId ID del negocio al que fue invitado
 * @param token Token de invitación
 * @param router Router de Next.js para redirecciones
 */
export async function handleBusinessInvitation(
  userId: string,
  businessId: string,
  token: string,
  router: AppRouterInstance
) {
  try {
    // Llamar a la API para aceptar la invitación
    const response = await fetch("/api/businesses/invitations/accept", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        invitationId: "", // Este valor se obtendrá en el servidor usando el token
        businessId,
        userId,
        token,
      }),
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || "Error al procesar la invitación");
    }

    toast.success("¡Invitación aceptada correctamente!");

    // Redirigir al dashboard del negocio
    router.push(`/business/${businessId}/dashboard`);
  } catch (error) {
    console.error("Error al procesar la invitación:", error);
    toast.error("Error al procesar la invitación", {
      description:
        "No se pudo completar el proceso de invitación. Por favor, contacta al administrador.",
    });

    // En caso de error, redirigir al dashboard general
    router.push("/dashboard");
  }
}

/**
 * Procede con la navegación normal después de la autenticación
 * @param userId ID del usuario autenticado
 * @param router Router de Next.js para redirecciones
 */
export async function proceedAfterAuthentication(
  userId: string,
  router: AppRouterInstance
) {
  try {
    // Aquí puedes agregar lógica para verificar el rol del usuario o sus negocios
    // Por ejemplo, verificar si es administrador de algún negocio

    // Por ahora, simplemente redirigimos al dashboard
    router.push("/dashboard");
  } catch (error) {
    console.error("Error al procesar la autenticación:", error);
    router.push("/dashboard");
  }
}
