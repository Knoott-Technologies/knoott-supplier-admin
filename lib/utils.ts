import { clsx, type ClassValue } from "clsx";
import { AppRouterInstance } from "next/dist/shared/lib/app-router-context.shared-runtime";
import { toast } from "sonner";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

/**
 * Formatea un valor numérico como precio en formato MXN,
 * donde los dos últimos dígitos representan centavos.
 *
 * Ejemplos:
 * - 10000 => $100.00
 * - 12345 => $123.45
 * - 50 => $0.50
 *
 * @param amount - Valor numérico donde los dos últimos dígitos son centavos
 * @returns Cadena formateada con el precio
 */
export const formatPrice = (amount: number): string => {
  // Dividir por 100 para convertir los últimos dos dígitos a centavos
  const valueWithDecimals = amount / 100;

  // Usar Intl.NumberFormat para formatear con símbolo de moneda y dos decimales fijos
  return new Intl.NumberFormat("es-MX", {
    style: "currency",
    currency: "MXN",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(valueWithDecimals);
};

// Lista de palabras ofensivas de 4 letras para evitar
const BLACKLIST = [
  "PUTO",
  "PUTA",
  "CULO",
  "CACA",
  "MOCO",
  "CAGA",
  "ANAL",
  "TETA",
  "PEDO",
  "PAJA",
  "CONO",
  "RABO",
  "PITO",
  "MAME",
  "JOTO",
  "COLA",
  "COME",
  "FALO",
  "FETO",
  "GUEY",
  "HUEV",
  "KACA",
  "KAGA",
  "KAKA",
  "KULO",
  "LAME",
  "LOCA",
  "MAMO",
  "MEAR",
  "MEON",
  "MIAR",
  "MION",
  "NACA",
  "NACO",
  "PEDA",
  "PENE",
  "POPO",
  "QULO",
  "RATA",
  "ROBA",
  "SIDA",
  "VACA",
  "VAGA",
  "VAGO",
  "WEBO",
  "WEON",
  "WEVA",
  "WEVO",
  "PAJA",
  "CAGO",
  "COJA",
  "PUTA",
  "PUTO",
  "ZORA",
  "PENE",
  "PITO",
  "PIJA",
  "CACA",
  "CULO",
  "CAGO",
  "CAGA",
  "MOCO",
  "MION",
  "PEDO",
  "ORTO",
  "OJTE",
  "OJTE",
  "PUTA",
  "PUTO",
  "RABO",
  "TETA",
  "VERG",
  "WEBO",
  "WEVA",
];

/**
 * Generate a 4 character reference from a given name.
 * The reference is generated by taking the first letter of each word,
 * and adding more letters from the first word if necessary.
 * If the generated reference is in the blacklist, the last character
 * is replaced with 'X'.
 * @param name The name to generate the reference from
 * @returns A 4 character reference string
 */
export function generateReferenceFromName(name: string): string {
  // Remove special characters and spaces
  const cleanName = name
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "") // Remove accents
    .replace(/[^\w\s]/gi, "") // Remove special characters
    .replace(/\s+/g, " ") // Replace multiple spaces with one
    .trim()
    .toUpperCase();

  // Generate initial reference
  let reference = "";
  const words = cleanName.split(" ");

  if (words.length === 1) {
    // If only one word, take first 4 characters
    reference = words[0].substring(0, 4);
  } else {
    // If multiple words, take first letter of each word
    for (let i = 0; i < Math.min(words.length, 4); i++) {
      if (words[i].length > 0) {
        reference += words[i].charAt(0);
      }
    }

    // If we don't have 4 letters yet, add more from the first word
    if (reference.length < 4 && words[0].length > 1) {
      reference += words[0].substring(1, 5 - reference.length);
    }
  }

  // Ensure reference is exactly 4 characters
  reference = reference.padEnd(4, "X").substring(0, 4);

  // Check if reference is in blacklist
  if (BLACKLIST.includes(reference)) {
    // Replace the last character with 'X'
    reference = reference.substring(0, 3) + "X";
  }

  return reference;
}

/**
 * Maneja la invitación de negocio después de la autenticación
 * @param userId ID del usuario autenticado
 * @param businessId ID del negocio al que fue invitado
 * @param token Token de invitación
 * @param router Router de Next.js para redirecciones
 */
export async function handleBusinessInvitation(
  userId: string,
  businessId: string,
  token: string,
  router: AppRouterInstance
) {
  try {
    // Llamar a la API para aceptar la invitación
    const response = await fetch("/api/businesses/invitations/accept", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        invitationId: "", // Este valor se obtendrá en el servidor usando el token
        businessId,
        userId,
        token,
      }),
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || "Error al procesar la invitación");
    }

    toast.success("¡Invitación aceptada correctamente!");

    // Redirigir al dashboard del negocio
    router.push(`/dahboard/${businessId}`);
  } catch (error) {
    console.error("Error al procesar la invitación:", error);
    toast.error("Error al procesar la invitación", {
      description:
        "No se pudo completar el proceso de invitación. Por favor, contacta al administrador.",
    });

    // En caso de error, redirigir al dashboard general
    router.push("/dashboard");
  }
}

/**
 * Procede con la navegación normal después de la autenticación
 * @param userId ID del usuario autenticado
 * @param router Router de Next.js para redirecciones
 */
export async function proceedAfterAuthentication(
  userId: string,
  router: AppRouterInstance
) {
  try {
    // Aquí puedes agregar lógica para verificar el rol del usuario o sus negocios
    // Por ejemplo, verificar si es administrador de algún negocio

    // Por ahora, simplemente redirigimos al dashboard
    router.push("/dashboard");
  } catch (error) {
    console.error("Error al procesar la autenticación:", error);
    router.push("/dashboard");
  }
}

// utils.ts - Funciones de utilidad para validación

interface CreateBusinessRequest {
  business_name: string;
  business_logo_url: string;
  business_legal_name: string;
  business_sector: string;
  street: string;
  external_number: string;
  neighborhood: string;
  postal_code: string;
  city: string;
  state: string;
  reference: string;
  main_phone_number?: string;
  contact_phone_number?: string;
  main_email?: string;
  description?: string;
  bank_account_number?: string;
  bank_name?: string;
  internal_number?: string;
  website_url?: string;
  tax_situation_url?: string;
}

export function validateBusinessData(data: any): data is CreateBusinessRequest {
  const requiredFields = [
    "business_name",
    "business_logo_url",
    "business_legal_name",
    "business_sector",
    "street",
    "external_number",
    "neighborhood",
    "postal_code",
    "city",
    "state",
    "reference",
  ];

  return requiredFields.every(
    (field) =>
      data[field] &&
      typeof data[field] === "string" &&
      data[field].trim().length > 0
  );
}

export function sanitizeBusinessData(
  data: CreateBusinessRequest
): CreateBusinessRequest {
  return {
    ...data,
    business_name: data.business_name.trim(),
    business_legal_name: data.business_legal_name.trim(),
    business_sector: data.business_sector.trim(),
    street: data.street.trim(),
    external_number: data.external_number.trim(),
    neighborhood: data.neighborhood.trim(),
    postal_code: data.postal_code.trim(),
    city: data.city.trim(),
    state: data.state.trim(),
    reference: data.reference.trim(),
    // Sanitizar campos opcionales
    main_phone_number: data.main_phone_number?.trim(),
    contact_phone_number: data.contact_phone_number?.trim(),
    main_email: data.main_email?.trim(),
    description: data.description?.trim(),
    bank_account_number: data.bank_account_number?.trim(),
    bank_name: data.bank_name?.trim(),
    internal_number: data.internal_number?.trim(),
    website_url: data.website_url?.trim(),
    tax_situation_url: data.tax_situation_url?.trim(),
  };
}
